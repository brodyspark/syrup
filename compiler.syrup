# WORK IN PROGRESS COMPILER PORT TO SYRUP
# Featuring such features like destructuring assignment
# and actual method calls

chunker = {
	"leftbracket": /^\[/
	"rightbracket": /^\]/
	"leftparen": /^\(/
	"rightparen": /^\)[;:]?/
	"leftbrace": /^\{/
	"rightbrace": /^\}/
	"quote": /^`/
	"indent": /^\n[\t ]*/
	"string": /^("([^\\"]|\\\\|\\")*"|'([^\\']|\\\\|\\')*')[:]?/
	"regex": /^\/([^\\\/]|\\\\|\\\/)*\//
	"callargs": /^[a-zA-Z_?=+-\/*!]+[:]/
	"call": /^[a-zA-Z_?=+\-\/*!\.]+[;](?!\b)/
	"atom": /^[a-zA-Z_?=+\-\/*!\.]+/
	"comma": /^,/
	"null": /^null/
	"bool": /^true|^false/
	"number": /^[0-9+]+/
	"comment": /^\#[^\n]+/
	}

exports.tokenize = fn: [code]
	loop: [code, tokens = []]
		patt = first: chunker, fn: [patt] patt.matches: c2
		assert: patt, 'Invalid code'
		[token] = patt.exec: c2
		unless: c2.length, tokens
			recur:
				code.substr: token.length;.replace: /^[\t ]+, ''
				{tokens, [[k, token]]}

exports.parse = fn: [code]
	tokens = exports.tokenize: code

	at = fn: [type] token[i] == type

	parseList: fn:
		if: at: 'indent'
			if: peek: 'indent'
				token = next;


exports.parse = (code) -> 
	tokens = exports.tokenize(code); i = 0
	
	# Return parse tree.
	res = []
	# Stack of current node, and indentation level
	stack = [[res, -1]]
	indent = 0

	at = (type) -> tokens[i]?[0] == type
	peek = (type) -> tokens[i+1]?[0] == type
	next = -> t = tokens[i]; i++; return t
	top = -> stack[stack.length-1]?[0]

	parseList = ->
		while i < tokens.length
			if at 'indent'
				# Subsequent newlines.
				if peek 'indent'
					token = next()
					continue
				# indented on newlines, part of list
				if stack[stack.length-1]?[1] < tokens[i][1].length-1
					token = next()
					indent = token[1].length-1
				else
					break
			if at 'comma'
				token = next()
			if not parseExpression() then break

	parseExpression = ->
		return unless tokens[i]

		while at 'comment'
			token = next()

		if at 'call'
			token = next()
			name = token[1][0...-1]
			top().push [name]
		else if at 'callargs'
			token = next()
			name = token[1][0...-1]
			top().push l = [name]
			stack.push [l, indent]
			parseList()
			stack.pop()
		else if at 'quote'
			token = next()
			l = ['quote']
			top().push l
			stack.push [l, indent]
			parseExpression()
			stack.pop()
		else if at 'leftbrace'
			token = next()
			l = ['combine']
			top().push l
			stack.push [l, indent]
			parseList()
			unless at 'rightbrace' then throw new Error 'Missing right brace'
			token = next()
			stack.pop()
		else if at 'leftbracket'
			token = next()
			l = ['list']
			top().push l
			stack.push [l, indent]
			parseList()
			unless at 'rightbracket' then throw new Error 'Missing right bracket'
			token = next()
			stack.pop()
		else if at 'leftparen'
			token = next()
			parseExpression()
			unless at 'rightparen' then throw new Error 'Missing right paren'
			token = next()
			if token[1][1] == ':'
				l = [top().pop()]
				top().push l
				stack.push [l, indent]
				parseList()
				stack.pop()
			else if token[1][1] == ';'
				l = [top().pop()]
				top().push l
		else if at 'string'
			token = next()
			isfunc = token[1].substr(-1) == ':'
			str = token[1].substr(1, token[1].length - 2 - Number(isfunc))
			top().push ['quote', str]
			if isfunc
				l = [top().pop()]
				top().push l
				stack.push [l, indent]
				parseList()
				stack.pop()
		else if at 'bool'
			token = next()
			top().push token[1] == 'true'
		else if at 'atom'
			token = next()
			top().push token[1]
		else if at 'number'
			token = next()
			top().push Number(token[1])
		else
			return false

		# Check if subsequent token is infix
		if at('atom') and tokens[i][1].match /^[+\-\/*=\.]+/
			op = tokens[i][1]; i++
			left = top().pop()
			unless parseExpression()
				throw new Error 'Missing right expression. Matched ' + tokens[i][0] + ' after ' + tokens[i-1][0] + ' (' + tokens[i-1] + ')'
			right = top().pop()
			top().push [op, left, right]

		return true

	parseList()

	->
		console.log 'Parse tree:'
		console.log(util.inspect(res, no, null))
		console.log '------------'

	return res